In a digital system, the system can understand only the optional number system. In these systems, digits symbols are used to represent different values, depending on the index from which it settled in the number system.

In simple terms, for representing the information, we use the number system in the digital system.


The digit value in the number system is calculated using:

1.  The digit
2.  The index, where the digit is present in the number.
3.  Finally, the base numbers, the total number of digits available in the number system.

#### Note: When the number system represents a digit from 0 - 9, the base of the number will be 10.

Types of Number System
----------------------

In the digital computer, there are various types of number systems used for representing information.

1.  Binary Number System
2.  Decimal Number System
3.  Hexadecimal Number System
4.  Octal Number System


### Binary Number System

Generally, a binary number system is used in the digital computers. In this number system, it carries only two digits, either 0 or 1. There are two types of electronic pulses present in a binary number system. The first one is the absence of an electronic pulse representing '0'and second one is the presence of electronic pulse representing '1'. Each digit is known as a bit. A four-bit collection (1101) is known as a nibble, and a collection of eight bits (11001010) is known as a byte. The location of a digit in a binary number represents a specific power of the base (2) of the number system.

**Characteristics:**

1.  It holds only two values, i.e., either 0 or 1.
2.  It is also known as the base 2 number system.
3.  The position of a digit represents the 0 power of the base(2). Example: 2<sup>0</sup>
4.  The position of the last digit represents the x power of the base(2). Example: 2<sup>x</sup>, where x represents the last position, i.e., 1

**Examples:**

(10100)<sub>2</sub>, (11011)<sub>2</sub>, (11001)<sub>2</sub>, (000101)<sub>2</sub>, (011010)<sub>2</sub>.

### Decimal Number System

The decimal numbers are used in our day to day life. The decimal number system contains ten digits from 0 to 9(base 10). Here, the successive place value or position, left to the decimal point holds units, tens, hundreds, thousands, and so on.

The position in the decimal number system specifies the power of the base (10). The 0 is the minimum value of the digit, and 9 is the maximum value of the digit. For example, the decimal number 2541 consist of the digit 1 in the unit position, 4 in the tens position, 5 in the hundreds position, and 2 in the thousand positions and the value will be written as:

```
(2×1000) + (5×100) + (4×10) + (1×1)
(2×10<sup>3</sup>) + (5×10<sup>2</sup>) + (4×10<sup>1</sup>) + (1×10<sup>0</sup>)
2000 + 500 + 40 + 1
2541
```

### Octal Number System

The octal number system has base 8(means it has only eight digits from 0 to 7). There are only eight possible digit values to represent a number. With the help of only three bits, an octal number is represented.  Each set of bits has a distinct value between 0 and 7.

Below, we have described certain characteristics of the octal number system:

**Characteristics:**

1.  An octal number system carries eight digits starting from 0, 1, 2, 3, 4, 5, 6, and 7.
2.  It is also known as the base 8 number system.
3.  The position of a digit represents the 0 power of the base(8). Example: 8<sup>0</sup>
4.  The position of the last digit represents the x power of the base(8). Example: 8<sup>x</sup>, where x represents the last position, i.e., 1

| Number | Octal Number |
| --- | --- |
| 0 | 000 |
| 1 | 001 |
| 2 | 010 |
| 3 | 011 |
| 4 | 100 |
| 5 | 101 |
| 6 | 110 |
| 7 | 111 |

**Examples:**

(273)<sub>8</sub>, (5644)<sub>8</sub>, (0.5365)<sub>8</sub>, (1123)<sub>8</sub>, (1223)<sub>8</sub>.

### Hexadecimal Number System

It is another technique to represent the number in the digital system called the **hexadecimal number system**. The number system has a base of 16 means there are total 16 symbols(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F) used for representing a number. The single-bit representation of decimal values10, 11, 12, 13, 14, and 15 are represented by A, B, C, D, E, and F. Only 4 bits are required for representing a number in a hexadecimal number. Each set of bits has a distinct value between 0 and 15. There are the following characteristics of the octal number system:

**Characteristics:**

1.  It has ten digits from 0 to 9 and 6 letters from A to F.
2.  The letters from A to F defines numbers from 10 to 15.
3.  It is also known as the base 16number system.
4.  In hexadecimal number, the position of a digit represents the 0 power of the base(16). Example: 16<sup>0</sup>
5.  In hexadecimal number, the position of the last digit represents the x power of the base(16). Example: 16<sup>x</sup>, where x represents the last position, i.e., 1

| Binary Number | Hexadecimal Number |
| --- | --- |
| 0000 | 0 |
| 0001 | 1 |
| 0010 | 2 |
| 0011 | 3 |
| 0100 | 4 |
| 0101 | 5 |
| 0110 | 6 |
| 0111 | 7 |
| 1000 | 8 |
| 1001 | 9 |
| 1010 | A |
| 1011 | B |
| 1100 | C |
| 1101 | D |
| 1110 | E |
| 1111 | F |

**Examples:**

(FAC2)<sub>16</sub>, (564)<sub>16</sub>, (0ABD5)<sub>16</sub>, (1123)<sub>16</sub>, (11F3)<sub>16</sub>.

---

# Types of Logic Gates

**Types of Logic Gate and its Applications-** The logic gates have the following types according to their function or working

1.  [OR gate](https://www.electroniclinic.com/logic-or-gate-working-principle-circuit-diagram/)
2.  [AND gate](https://www.electroniclinic.com/logic-and-gate-working-principle-circuit-diagram/)
3.  [NOT gate](https://www.electroniclinic.com/logic-not-gate-working-principle-circuit-diagram/)
4.  [NOR gate](https://www.electroniclinic.com/logic-nor-gate-working-principle-circuit-diagram/)
5.  [NAND gate](https://www.electroniclinic.com/logic-nand-gate-working-principle-circuit-diagram/)
6.  [Exclusive OR gate or XOR](https://www.electroniclinic.com/exclusive-or-gate-xor-working-principle-circuit-diagram/)
7.  [Exclusive NOR gate or XNOR](https://www.electroniclinic.com/exclusive-nor-gate-or-xnor-working-principle-circuit-diagram/)

Figure 2.3 – AND, OR, NOT, NAND, NOR, X OR and X NOR

![Gate](https://www.electroniclinic.com/wp-content/uploads/2022/08/AND-OR-NOT-NAND-NOR-X-OR-and-X-NOR-529x720.jpg)

**Different Types of Logic Gates**
----------------------------------

In figure 2.34, a summary of different types of logic gates has been presented.

![Gate](https://www.electroniclinic.com/wp-content/uploads/2022/08/summary-of-different-types-of-logic-gates-has-been-presented-504x720.jpg)

The range of usage of logic gates is quite extensive, however some of its distinct applications are as follows:

1.  In manufacturing more complex devices e.g. binary counters etc.
2.  In decision–making regarding automatic control of machines and different industrial processes
3.  In calculators and computers
4.  In digital measuring techniques
5.  In digital processing of communications
6.  In musical instruments, games and different domestic appliances

**Logic Gate Families**
-----------------------

A large number of digital systems are designed by mixing a number of different logic functions (e.g. OR, AND, Inverter, NAND, NOR, XOR and XNOR). All such logic circuits are available in IC modules and these modules have been distributed into different families. Every family is denoted by a few short words or abbreviations, which indicate the type of logic circuit being used in this family. For example, RTL means resistor, transistor logic. These days, the following seven transistor logic families are more famous, though the usage of the first two of these seven families has become confined or almost finished these days. However, here these are narrated just from the point of view of a historical perspective.

1.  Resistor Transistor Logic (RTL)- This was the first family group of logic circuits, which was developed and packed in the shape of IC in 1960 (that’s it was manufactured in the shape of an IC and was closed in an IC packing)
2.  Diode Transistor Logic (DTL) – it was manufactured after RTL in the end of 1960.
3.  Transistor- Transistor logic (TTL or TL)- It was introduced in the beginning of 1970
4.  Shot Key TTL- It was manufactured in order to enhance the speed of TTL
5.  Emitter Coupled Logic (ECL) – This is the fastest logic line amongst all the logic lines available these days.
6.  Integrated Injection Logic (IIL) or (IL) – This is the latest form of bipolar types of logic
7.  Complementary Metal Oxide Conductor (CMOS) – This logic circuit is very famous and popular due to its least power consumption feature as compared to all other available logic circuits. Moreover, these are also less costly and quite speedy.

Prior to knowing the details (which is coming ahead) of different logic families, it is essential to understand its various characteristics, because all families have different characteristics.

**Saturated and Non-saturated logic**
-------------------------------------

Logic circuits, in which transistor function or drive in a state of saturation, are known as saturated logic circuits or simply saturated logic. One of the disadvantages of this circuit is that when transistor is brought out from its saturation state, they take some time in coming out from that state. (i.e. when a saturated circuit is turned off, it does not turn of instantly, rather it tends to turn off after some delay, which is its greatest demerit). It is because when a transistor saturates, in such a situation its base is flooded with majority carriers (by means of which an extensive current continues passing through it), until even if the base voltages are turned off, as has been revealed in the figure 2.35, even then the flow of carriers from its base tends to continue for some time. That’s if its base voltages are turned off for turning the transistor off, even then its base remains flooded with carriers as the base requires some time for these carriers to flush out completely (i.e. even after transistor turns off, carriers keep transmitting through the base for quite some time, until all carriers have been depleted). In case of saturation, the time required for the current carriers existing on any transistors’ base, pushing out from the transistor’s base, after it has been turned off, is known as saturation delay time (Ts). (In simple words, the time required for ejecting out carriers present on the base of a transistor, is called saturation delay time). Therefore, due to this very reason, the switching speed of a saturated logic circuit is low. Transistor transistor logic circuit (TTL) is an example of saturated logic circuits.

Figure 2.35 – switching action of transistor

![Gate](https://www.electroniclinic.com/wp-content/uploads/2022/08/switching-action-of-transistor-638x720.jpg)

The logic circuits, in which transistors function in a state of non – saturation (or the logic circuits, in which transistors are protected from its saturation), are called non–saturated logic circuits. The switching speed of such circuits is very fast (that’s in situations of non – saturation, a transistor turns off abruptly, therefore, this circuit is enormously speedy because of its very low delay time). Remember that ECL (emitter coupled logic) is an example of non – saturated logic circuit.

---
# K-map

In many digital circuits and practical problems, we need to find expressions with minimum variables. We can minimize Boolean expressions of 3, 4 variables very easily using K-map without using any Boolean algebra theorems.

K-map can take two forms:

1.  Sum of product (SOP)
2.  Product of Sum (POS)

According to the need of problem. K-map is a table-like representation, but it gives more information than the TABLE. We fill a grid of the K-map with 0’s and 1’s then solve it by making groups.

****Steps to Solve Expression using K-map****
---------------------------------------------

1.  Select the K-map according to the number of variables.
2.  Identify minterms or maxterms as given in the problem.
3.  For SOP put 1’s in blocks of K-map respective to the minterms (0’s elsewhere).
4.  For POS put 0’s in blocks of K-map respective to the max terms (1’s elsewhere).
5.  Make rectangular groups containing total terms in power of two like 2,4,8 ..(except 1) and try to cover as many elements as you can in one group.
6.  From the groups made in step 5 find the product terms and sum them up for SOP form.

****SOP FORM****
----------------

### ****1\. K-map of 3 variables****

![](https://media.geeksforgeeks.org/wp-content/uploads/20220613125859/k3sop-300x295.png)

K-map SOP form for 3 variables

```
<span>Z= ?A,B,C(1,3,6,7)&nbsp; </span>
```

![SOP](https://media.geeksforgeeks.org/wp-content/uploads/K-Map-Karnaugh-Map.png)

From ****red**** group we get product term— 

```
<span>A’C&nbsp;</span>
```

From ****green**** group we get product term— 

```
<span>AB&nbsp;</span>
```

Summing these product terms  we get- ****Final expression (A’C+AB)**** 

### ****2\. K-map for 4 variables****

![K-map 4 variable SOP form](https://media.geeksforgeeks.org/wp-content/uploads/20220613125927/k4sop-287x300.png)

K-map 4 variable SOP form

```
<span>F(P,Q,R,S)=?(0,2,5,7,8,10,13,15)&nbsp; </span>
```

From ****red**** group we get product term— 

```
<span>QS&nbsp;</span>
```

From ****green**** group we get product term— 

```
<span>Q’S’&nbsp;</span>
```

Summing  these product terms  we get- ****Final expression (QS+Q’S’)****.

****POS FORM****
----------------

### ****1\. K-map of 3 variables****

![POS](https://media.geeksforgeeks.org/wp-content/uploads/20220613125908/k3pos-300x295.png)

K-map 3 variable POS form

```
<span>F(A,B,C)=?(0,3,6,7)</span>
```

![POS](https://media.geeksforgeeks.org/wp-content/uploads/20211109194324/Screenshot281.png)

From ****red**** group we find terms 

```
<span>A&nbsp;&nbsp;&nbsp; B&nbsp;&nbsp;&nbsp;</span>
```

Taking complement of these two 

```
<span>A'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B'&nbsp;&nbsp;&nbsp; </span>
```

Now ****sum**** up them 

```
<span>(A' + B')&nbsp;</span>
```

From ****brown**** group we find terms 

```
<span>B&nbsp;&nbsp; C&nbsp;</span>
```

Taking complement of these two terms 

```
<span>B’&nbsp; C’&nbsp;</span>
```

Now sum up them 

```
<span>(B’+C’)&nbsp;</span>
```

From ****yellow**** group we find terms 

```
<span>A' B' C’&nbsp;</span>
```

Taking complement of these two 

```
<span>A B C&nbsp;</span>
```

Now ****sum**** up them 

```
<span>(A + B + C)&nbsp;</span>
```

We will take product of these three terms : ****Final expression –****

```
<b><strong>(A' + B’) (B’ + C’) (A + B + C)</strong></b><span>&nbsp;</span>
```

### ****2\. K-map of  4 variables****  

![4 variables](https://media.geeksforgeeks.org/wp-content/uploads/20220613125920/k4pos-287x300.png)

K-map 4 variable POS form

```
<span>F(A,B,C,D)=?(3,5,7,8,10,11,12,13)&nbsp;</span>
```

![](https://media.geeksforgeeks.org/wp-content/uploads/20200821002803/KMapKarnaughMap3correct01-300x300.png)

From ****green**** group we find terms 

```
<span>C’&nbsp; D&nbsp; B&nbsp;</span>
```

Taking their complement and summing them 

```
<span>(C+D’+B’)&nbsp;</span>
```

From ****red**** group we find terms 

```
<span>C&nbsp; D&nbsp; A’&nbsp;</span>
```

Taking their complement and summing them 

```
<span>(C’+D’+A)&nbsp;</span>
```

From ****blue****  group we find terms

```
<span>A&nbsp; C’&nbsp; D’&nbsp;</span>
```

Taking their complement and summing them 

```
<span>(A’+C+D)&nbsp;</span>
```

From ****brown****  group we find terms

```
<span>A&nbsp; B’&nbsp; C&nbsp;</span>
```

Taking their complement and summing them 

```
<span>(A’+B+C’)&nbsp;</span>
```

Finally we express these as product –

```
<b><strong>(C+D’+B’).(C’+D’+A).(A’+C+D).(A’+B+C’)</strong></b><span>&nbsp;</span>
```

<u><b><strong>PITFALL</strong></b></u>****–****  \*Always remember _****POS ? (SOP)’****_ 

\*The correct form is (****POS of F)=(SOP of F’)’**** 

---
# Combinational Logic

Combinational circuits are very well known components in digital electronics which can provide output instantly based on the current input. Unlike sequential circuits, a combinational circuit listens for input signal and and generates output no matter what is the past input or state as it has no feedback or memory component. It only cares about present input and state.

Definition of Combinational Circuit
-----------------------------------

[Combinational circuits](https://www.geeksforgeeks.org/construction-of-combinational-circuits/) are specially designed using multiple interconnected [logic gates](https://www.geeksforgeeks.org/logic-gates-definition-types-uses/) such that the output will be generated by computing the logical combinations of the present input only. No clock pulse is present here. Moreover, no previously stored value or state is taken into consideration here. The output is independent of previous states.

Features of Combinational Circuit
---------------------------------

*   In this output depends only upon present input.
*   It’s Speed is fast.
*   Easy designed.
*   There is no feedback between input and output.
*   It is time independent.
*   Elementary building blocks are Logic gates.
*   Used for both [arithmetic](https://www.geeksforgeeks.org/arithmetic-operators-in-c/) and [boolean operations](https://www.geeksforgeeks.org/introduction-to-boolean-logic/).
*   Combinational circuits don’t have the capability to store any state.

![combinational-circuit.png](https://media.geeksforgeeks.org/wp-content/uploads/20230703130127/combinational-circuit.png)

****Examples****

In areas combinational circuits are used which are discusses below:

*   [****Adders and Subtractors:****](https://www.geeksforgeeks.org/adders-and-subtractors-in-digital-logic/) Combinational circuits are used to perform mathematical operations of [binary numbers](https://www.geeksforgeeks.org/binary-numbers-of-n-digits/). Adder and Subtractor uses combinational circuit logic where in takes two or more binary numbers as input and performs addition/subtraction to generate output.
*   [****Multiplexers and Demultiplexers:****](https://www.geeksforgeeks.org/difference-between-multiplexer-and-demultiplexer/) [Multiplexer](https://www.geeksforgeeks.org/multiplexers-in-digital-logic/) is a special kind of combinational circuit where several number of inputs are present. From that one input can be selected and that will be transmitted as an output based on selection signal. In the other hand, [Demultiplexers](https://www.geeksforgeeks.org/what-is-a-demultiplexer/) also select one input signal but transmits it to one of the several outputs.
*   [****Encoders and Decoders:****](https://www.geeksforgeeks.org/encoders-and-decoders-in-digital-logic/) [Encoders](https://www.geeksforgeeks.org/encoder-in-digital-logic/) also uses combinational circuits to convert a multiple set of input signal to smaller set of output signal but the resultant value is unchanged. Inversely, [Decoders](https://www.geeksforgeeks.org/binary-decoder-in-digital-logic/) converts a small set of input signal to a large set of output signal without changing the resultant value. Basically input of Encoder = output of Decoder and vice versa.

### Applications of Combinational Circuit

In modern technologies, combinational circuits are widely used for its simple functionality and ability to give instant output. Some of the applications are discussed below:

*   [****Arithmetic and Logic Units (ALUs):****](https://www.geeksforgeeks.org/introduction-of-alu-and-data-path/) As combinational circuits are capable of performing various mathematical tasks like arithmetic and logical operations so, these circuits are used in calculators and processors as a fundamental component of ALU.
*   [****Data Encryption****](https://www.geeksforgeeks.org/what-is-data-encryption/) ****and Decryption:**** In information protection fields, combinational circuit are used for encryption and decryption of data for secure communication. Encryption/decryption algorithms are also a complex mathematical formula which can be performed by combinational circuits.
*   ****Data Multiplexing and Demultiplexing:**** It is just a practical implementation of multiplexer and demultiplexer. By using it we can optimize network bandwidth by effectively reducing network traffic as combinational circuit allows to transmit multiple data signals over a single communication channel.
*   ****Traffic Light Control:**** In traffic lights control mechanism, combinational circuits are used to instantly determine the timing and sequence of traffic light changes based on the inputs of timers and sensors.

### Advantages of Combinational Circuit

Some basic advantages of combinational circuits has made them very popular among modern technologies which are discussed below:

*   ****Simplicity:**** Combinational circuits are very easy to implement and absence of memory or feedback element has made it more straightforward which is reducing complexity in digital systems and providing faster prototype building mechanism.
*   ****Real-time Operation:**** Combinational circuits don’t face any delay which is very much essential for quick-response applications like data transmission and signal processing.
*   ****Deterministic Behavior:**** Combinational circuits generate output based on present input only which ensures predictable and repeatable results which is essential for applications in which consistency and reliability is required.

### Disadvantages of Combinational Circuit

*   ****Limited Functionality:**** As it provides output only based on present input and there is no way to store previous data so we can’t use this circuit to any memory-based applications or where previous data is recalled for doing operations.
*   ****Lack of Flexibility:**** Once the design of logic gates is done then for changing a small design required the entire redesigning of the circuits which is monotonous and time-consuming.
*   ****Increased Complexity for Large Designs:**** For large designs the number of [logic gates](https://www.geeksforgeeks.org/introduction-of-logic-gates/) will increase gradually which means the management of input and output ports will become very complex. This may lead to higher production costs and increased design errors.

---
# BCD Adder
![](https://steemitimages.com/640x0/http://www.differencebetween.info/sites/default/files/images/2/demultiplexer.jpg)

    Hello I'm back and this time we will talk about more **Advanced Circuits**! I will start off with **Multiplexers**, continue with **Encoders** and finish with **Decoders**! So, without further do let's get started!

Multiplexers:
-------------

    A Multiplexer is a circuit that selects one of **2^n inputs** from **n selection lines** and gives **1 specific Output**! A **MUX** is also called a **Data Selector**. So, we have **2^n-to-1 Multiplexers**, where **n is the number of selection lines**. For example, MUX 2-to-1, 4-to-1, 8-to-1 etc. 

![](https://steemitimages.com/640x0/http://4.bp.blogspot.com/-VCRUbhxo2bw/UrpzadWivJI/AAAAAAAAAWM/cOKfyxvCWq8/s400/Mux_with_truthtable.png)4-to-1 Mux and Truth Table!

An 4-to-1 mux for example will have 2 Selection Lines and will work for 3 Variable Input!

    To define those Inputs we have to know what kind of **Outputs** we have **in every** **Input combination**. So, we will use **N-1 of the Inputs Variables as Selection Inputs** to define minterm groups and afterwards compare the value of **the other Variable** (01) with the one of the Outputs of the minterm groups (you will understand it better in a minute). This Comparation will give us our **"I" Inputs** for the Multiplexer!

**Example:**

Let's take F(X, Y, Z) for example that has **minterms at** the binary values of **1, 3, 4, 5**.

The **Truth Table** looks like this:

![](https://steemitimages.com/640x0/https://s26.postimg.org/f3zzfddgp/image.png)

    We will take **Y, Z as selection**_s_ and form groups of 01 for X, where YZ need to be the same (like minterms). So, we will create an array that contains X, the Output F and I that will be the comparition result. Taking the first and fifth row for example we see that only X changes so we have X and F be 01 and so I is X! We continue like this and end up with this:

![](https://steemitimages.com/640x0/https://s26.postimg.org/ic4gsezqh/image.png)

    I0 = X, I1 = 1, I2 = 0 and I3 = X'. That will be the Inputs for our Multiplexer having Y and Z be the Selection Line Inputs! The Output of this 4-to-1 Mux will follow the Truth Table of F(X, Y, Z).

    We can do the same using XZ or XY as Selections, again forming groups where the other value changes (01) but the Selections stay the same! We can also use this concept in bigger MUX's with ease.

The **Circuit** in Multisim can looks like this for example:

![](https://steemitimages.com/640x0/https://s26.postimg.org/gbiilbsyx/image.png)

    You can see that we put X, 1, 0,X' as "I" Inputs and Y, Z as Selections. Having XYZ be 001 (1) we see that the Output becomes 1, because it follows the Truth Table of F!

Encoders:
---------

    Encoders convert information from one format to another to compress data. In Circuits they **compress multiple lines of inputs into a smaller number of outputs**! In Encoders the number of Outputs depends on the number of Input "Rows" and they are complicated and need an implementation every time! That's why we mostly use **Priority Encoders** and those are the ones that I will talk about! In them **when having more then 1 Inputs** be active at once, the one in **the most left** has the **highest priority** and gets selected! The number of Output lines depends on the different Inputs we can have, so we are able of having 4-to-2 , 8-to-3 encoders and so on...that follow the rule of **2^n-to-n Encoder**. 

![](https://steemitimages.com/640x0/https://www.tutorialspoint.com/computer_logical_organization/images/priorityencoder_blockdiagram.jpg)4-to-2 Encoder

    We will have to write a Circuit for an Encoder using the Inputs and Outputs of an Truth Table that represents the functionality of such an Encoder!

**Example:**

    Let's take this **Truth Table** for example that defines an 4-to-2 Encoder:

![](https://steemitimages.com/640x0/https://s26.postimg.org/m3n867s6h/image.png)

    The **X's represent don't cares**. We put them cause the most left input has the highest priority on so the value of the others is ignored! You can also see that we have one more Output called **Z**, whose value tells us if we have an **valid Output**!

    So, to implement this Encoder we will have to write **a function** that will be translated into a Circuit **for each** **of the Outputs**! It's not too difficult in this one!

Using **Karnaugh Map** for each of those I ended up with this **Circuit**:

![](https://steemitimages.com/640x0/https://s26.postimg.org/clnh666i1/image.png)

Decoders:
---------

    Decoders are the **opposite** of an **Encoder** and they actually can also be called **Demultiplexers** or **DEMUX**, cause they also work as the **opposite** of an **Multiplexer**! The only **difference** between DEMUX's and Decoders is actually that the first uses only **1 Input** and gives us **2^n Outputs**, and the second uses **n Inputs** and gives us **2^n Outputs**! I will talk about Decoders to keep things simple, cause DEMUX are more complicated! 

![](https://steemitimages.com/0x0/https://cdn.instructables.com/F8R/QUI5/HQ0HSVLJ/F8RQUI5HQ0HSVLJ.MEDIUM.gif)

    As I already said the Decoder is the opposite of an Encoder, so using the Outputs of an Encoder as Inputs in it's corresponding Decoder we get the Inputs that gave us this Outputs in the Encoder! So, we get the Inputs back! But, this is not the way we use them, cause it can be made much simpler!

    An Decoder **can't have more then 1 Outputs lines have a value of 1**! Cause each Output line represents an Combination (binary number) of Inputs. So, **each Output line represents an minterm or maxterm** of our function! A Decoder mostly has an **inverted Output** so we will have to **use maxterms** or **use minterms and invert the Outputs using an NAND Gate**!

Using that logic we can **implement any Circuit**, **knowing only** where it has **minterms** or **maxterms**!

**Example:**

    Last time we talked about Full-Adders. Let's implement one using an Decoder! We have to use an 3-to-8 Decoder, cause we have 3 Inputs. 

The Truth Table looks like this (if you remember):

![](https://steemitimages.com/640x0/https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQEYzRGEf1mXdt3v_IWEEXDybmv2c2mi7rvi-zdH3apvvKDVvPHuw)

    To use an Decoder for that Circuit we simply have to put a Multi-Input NAND Gate (if Outputs are inverted, else OR) for each of the Outputs and the Inputs will be the corresponding Outputs the Decoder gives us for each Input Combination (Minterms)!

So, we end up with this **Circuit**:

![](https://steemitimages.com/640x0/https://s26.postimg.org/vxdmai92h/image.png)


---
![](https://steemitimages.com/640x0/http://www.differencebetween.info/sites/default/files/images/2/demultiplexer.jpg)

    Hello I'm back and this time we will talk about more **Advanced Circuits**! I will start off with **Multiplexers**, continue with **Encoders** and finish with **Decoders**! So, without further do let's get started!

Multiplexers:
-------------

    A Multiplexer is a circuit that selects one of **2^n inputs** from **n selection lines** and gives **1 specific Output**! A **MUX** is also called a **Data Selector**. So, we have **2^n-to-1 Multiplexers**, where **n is the number of selection lines**. For example, MUX 2-to-1, 4-to-1, 8-to-1 etc. 

![](https://steemitimages.com/640x0/http://4.bp.blogspot.com/-VCRUbhxo2bw/UrpzadWivJI/AAAAAAAAAWM/cOKfyxvCWq8/s400/Mux_with_truthtable.png)4-to-1 Mux and Truth Table!

An 4-to-1 mux for example will have 2 Selection Lines and will work for 3 Variable Input!

    To define those Inputs we have to know what kind of **Outputs** we have **in every** **Input combination**. So, we will use **N-1 of the Inputs Variables as Selection Inputs** to define minterm groups and afterwards compare the value of **the other Variable** (01) with the one of the Outputs of the minterm groups (you will understand it better in a minute). This Comparation will give us our **"I" Inputs** for the Multiplexer!

**Example:**

Let's take F(X, Y, Z) for example that has **minterms at** the binary values of **1, 3, 4, 5**.

The **Truth Table** looks like this:

![](https://steemitimages.com/640x0/https://s26.postimg.org/f3zzfddgp/image.png)

    We will take **Y, Z as selection**_s_ and form groups of 01 for X, where YZ need to be the same (like minterms). So, we will create an array that contains X, the Output F and I that will be the comparition result. Taking the first and fifth row for example we see that only X changes so we have X and F be 01 and so I is X! We continue like this and end up with this:

![](https://steemitimages.com/640x0/https://s26.postimg.org/ic4gsezqh/image.png)

    I0 = X, I1 = 1, I2 = 0 and I3 = X'. That will be the Inputs for our Multiplexer having Y and Z be the Selection Line Inputs! The Output of this 4-to-1 Mux will follow the Truth Table of F(X, Y, Z).

    We can do the same using XZ or XY as Selections, again forming groups where the other value changes (01) but the Selections stay the same! We can also use this concept in bigger MUX's with ease.

The **Circuit** in Multisim can looks like this for example:

![](https://steemitimages.com/640x0/https://s26.postimg.org/gbiilbsyx/image.png)

    You can see that we put X, 1, 0,X' as "I" Inputs and Y, Z as Selections. Having XYZ be 001 (1) we see that the Output becomes 1, because it follows the Truth Table of F!

Encoders:
---------

    Encoders convert information from one format to another to compress data. In Circuits they **compress multiple lines of inputs into a smaller number of outputs**! In Encoders the number of Outputs depends on the number of Input "Rows" and they are complicated and need an implementation every time! That's why we mostly use **Priority Encoders** and those are the ones that I will talk about! In them **when having more then 1 Inputs** be active at once, the one in **the most left** has the **highest priority** and gets selected! The number of Output lines depends on the different Inputs we can have, so we are able of having 4-to-2 , 8-to-3 encoders and so on...that follow the rule of **2^n-to-n Encoder**. 

![](https://steemitimages.com/640x0/https://www.tutorialspoint.com/computer_logical_organization/images/priorityencoder_blockdiagram.jpg)4-to-2 Encoder

    We will have to write a Circuit for an Encoder using the Inputs and Outputs of an Truth Table that represents the functionality of such an Encoder!

**Example:**

    Let's take this **Truth Table** for example that defines an 4-to-2 Encoder:

![](https://steemitimages.com/640x0/https://s26.postimg.org/m3n867s6h/image.png)

    The **X's represent don't cares**. We put them cause the most left input has the highest priority on so the value of the others is ignored! You can also see that we have one more Output called **Z**, whose value tells us if we have an **valid Output**!

    So, to implement this Encoder we will have to write **a function** that will be translated into a Circuit **for each** **of the Outputs**! It's not too difficult in this one!

Using **Karnaugh Map** for each of those I ended up with this **Circuit**:

![](https://steemitimages.com/640x0/https://s26.postimg.org/clnh666i1/image.png)

Decoders:
---------

    Decoders are the **opposite** of an **Encoder** and they actually can also be called **Demultiplexers** or **DEMUX**, cause they also work as the **opposite** of an **Multiplexer**! The only **difference** between DEMUX's and Decoders is actually that the first uses only **1 Input** and gives us **2^n Outputs**, and the second uses **n Inputs** and gives us **2^n Outputs**! I will talk about Decoders to keep things simple, cause DEMUX are more complicated! 

![](https://steemitimages.com/0x0/https://cdn.instructables.com/F8R/QUI5/HQ0HSVLJ/F8RQUI5HQ0HSVLJ.MEDIUM.gif)

    As I already said the Decoder is the opposite of an Encoder, so using the Outputs of an Encoder as Inputs in it's corresponding Decoder we get the Inputs that gave us this Outputs in the Encoder! So, we get the Inputs back! But, this is not the way we use them, cause it can be made much simpler!

    An Decoder **can't have more then 1 Outputs lines have a value of 1**! Cause each Output line represents an Combination (binary number) of Inputs. So, **each Output line represents an minterm or maxterm** of our function! A Decoder mostly has an **inverted Output** so we will have to **use maxterms** or **use minterms and invert the Outputs using an NAND Gate**!

Using that logic we can **implement any Circuit**, **knowing only** where it has **minterms** or **maxterms**!

**Example:**

    Last time we talked about Full-Adders. Let's implement one using an Decoder! We have to use an 3-to-8 Decoder, cause we have 3 Inputs. 

The Truth Table looks like this (if you remember):

![](https://steemitimages.com/640x0/https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQEYzRGEf1mXdt3v_IWEEXDybmv2c2mi7rvi-zdH3apvvKDVvPHuw)

    To use an Decoder for that Circuit we simply have to put a Multi-Input NAND Gate (if Outputs are inverted, else OR) for each of the Outputs and the Inputs will be the corresponding Outputs the Decoder gives us for each Input Combination (Minterms)!

So, we end up with this **Circuit**:

![](https://steemitimages.com/640x0/https://s26.postimg.org/vxdmai92h/image.png)






---
# Sequential Logic

Sequential Circuits are those which have the notion of an _internal state_. This notion of _Internal State_ is necessary because in sequential circuits, the output of the circuit is function of both the present input as well as the past inputs. The Internal State of a sequential circuit is nothing but the reflection of the past inputs to the circuit. Now the Internal State of a Sequential Circuit is represented by a number of _State Variables_. Each state variable can be in 1 of 2 possible states. This is because State Variables are physically implemented with the help of Flip-Flops, and each Flip-Flop can only represent 2 possible states. Therefore, if we have ‘N’ Flip-Flops, we can represent a maximum of 2<sup>N</sup> states.

```
Max. No. of States with 'N' Flip-Flops = <img src="https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-01541c61fb4c2879c48fedb9eb84d1c6_l3.svg" alt="2^N" title="Rendered by QuickLaTeX.com" height="23" width="30">
```

This means that a Sequential Circuit having ‘N’ Flip-Flops can be in at most ![2^N  ](https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-e5bbc5658773677d1b9aae0ca5b1341d_l3.svg "Rendered by QuickLaTeX.com")Internal States. Now let’s illustrate the difference between that of [Synchronous](https://www.geeksforgeeks.org/introduction-of-sequential-circuits/) and [Asynchronous Sequential Circuits](https://www.geeksforgeeks.org/asynchronous-sequential-circuits/) with the example of a Synchronous and Asynchronous 2-bit binary UP Counter using T-Flip-Flops. 

![](https://media.geeksforgeeks.org/wp-content/uploads/Untitled-Diagram-33.png)

2-bit Binary Asynchronous UP Counter

![](https://media.geeksforgeeks.org/wp-content/uploads/Untitled-Diagram1-2.png)

2-bit Binary Synchronous UP Counter

In both the above circuits ![Q_0, Q_1  ](https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-f25193ec9402a5344ae520cb1959f7b6_l3.svg "Rendered by QuickLaTeX.com")are the State Variables denoting the _Internal State_ of each of the above circuits. Since there are 2 state variable the above sequential circuits can be in 4 possible states, and the function of a counter is to cycle through these 4 states in a particular order. Now the difference between Synchronous and Asynchronous Circuits is in how the circuit goes for one Internal State to the Next Internal State. In a Synchronous Sequential Circuit all the State Variables representing the internal state of the circuit change their state simultaneously with a given input clock signal to achieve the next state. On the other hand in case of an Asynchronous Circuit all the State Variables may not change their state simultaneously to achieve the next steady internal state. In other words the state variables are not synchronized with any universal clock signal. **Comparisons –**

| Synchronous Circuit | Asynchronous Circuit |
| --- | --- |
| All the **State Variable** changes are synchronized with a universal clock signal. | The **State Variables** are not synchronized to change simultaneously and may change at anytime irrespective of each other to achieve the next **Steady Internal State** |
| Since all the Internal State changes are in the strict control of a master clock source they are less prone to failure or to a race condition and hence are more reliable. | Since there is no such universal clock source, the internal state changes as soon as any of the inputs change and hence are more prone to a race condition. |
| Timings of the internal state changes are in our control. | The changes in the internal state of an asynchronous circuit are not in our control. |




---

![](https://steemitimages.com/640x0/http://www.differencebetween.info/sites/default/files/images/2/demultiplexer.jpg)

    Hello I'm back and this time we will talk about more **Advanced Circuits**! I will start off with **Multiplexers**, continue with **Encoders** and finish with **Decoders**! So, without further do let's get started!

Multiplexers:
-------------

    A Multiplexer is a circuit that selects one of **2^n inputs** from **n selection lines** and gives **1 specific Output**! A **MUX** is also called a **Data Selector**. So, we have **2^n-to-1 Multiplexers**, where **n is the number of selection lines**. For example, MUX 2-to-1, 4-to-1, 8-to-1 etc. 

![](https://steemitimages.com/640x0/http://4.bp.blogspot.com/-VCRUbhxo2bw/UrpzadWivJI/AAAAAAAAAWM/cOKfyxvCWq8/s400/Mux_with_truthtable.png)4-to-1 Mux and Truth Table!

An 4-to-1 mux for example will have 2 Selection Lines and will work for 3 Variable Input!

    To define those Inputs we have to know what kind of **Outputs** we have **in every** **Input combination**. So, we will use **N-1 of the Inputs Variables as Selection Inputs** to define minterm groups and afterwards compare the value of **the other Variable** (01) with the one of the Outputs of the minterm groups (you will understand it better in a minute). This Comparation will give us our **"I" Inputs** for the Multiplexer!

**Example:**

Let's take F(X, Y, Z) for example that has **minterms at** the binary values of **1, 3, 4, 5**.

The **Truth Table** looks like this:

![](https://steemitimages.com/640x0/https://s26.postimg.org/f3zzfddgp/image.png)

    We will take **Y, Z as selection**_s_ and form groups of 01 for X, where YZ need to be the same (like minterms). So, we will create an array that contains X, the Output F and I that will be the comparition result. Taking the first and fifth row for example we see that only X changes so we have X and F be 01 and so I is X! We continue like this and end up with this:

![](https://steemitimages.com/640x0/https://s26.postimg.org/ic4gsezqh/image.png)

    I0 = X, I1 = 1, I2 = 0 and I3 = X'. That will be the Inputs for our Multiplexer having Y and Z be the Selection Line Inputs! The Output of this 4-to-1 Mux will follow the Truth Table of F(X, Y, Z).

    We can do the same using XZ or XY as Selections, again forming groups where the other value changes (01) but the Selections stay the same! We can also use this concept in bigger MUX's with ease.

The **Circuit** in Multisim can looks like this for example:

![](https://steemitimages.com/640x0/https://s26.postimg.org/gbiilbsyx/image.png)

    You can see that we put X, 1, 0,X' as "I" Inputs and Y, Z as Selections. Having XYZ be 001 (1) we see that the Output becomes 1, because it follows the Truth Table of F!

Encoders:
---------

    Encoders convert information from one format to another to compress data. In Circuits they **compress multiple lines of inputs into a smaller number of outputs**! In Encoders the number of Outputs depends on the number of Input "Rows" and they are complicated and need an implementation every time! That's why we mostly use **Priority Encoders** and those are the ones that I will talk about! In them **when having more then 1 Inputs** be active at once, the one in **the most left** has the **highest priority** and gets selected! The number of Output lines depends on the different Inputs we can have, so we are able of having 4-to-2 , 8-to-3 encoders and so on...that follow the rule of **2^n-to-n Encoder**. 

![](https://steemitimages.com/640x0/https://www.tutorialspoint.com/computer_logical_organization/images/priorityencoder_blockdiagram.jpg)4-to-2 Encoder

    We will have to write a Circuit for an Encoder using the Inputs and Outputs of an Truth Table that represents the functionality of such an Encoder!

**Example:**

    Let's take this **Truth Table** for example that defines an 4-to-2 Encoder:

![](https://steemitimages.com/640x0/https://s26.postimg.org/m3n867s6h/image.png)

    The **X's represent don't cares**. We put them cause the most left input has the highest priority on so the value of the others is ignored! You can also see that we have one more Output called **Z**, whose value tells us if we have an **valid Output**!

    So, to implement this Encoder we will have to write **a function** that will be translated into a Circuit **for each** **of the Outputs**! It's not too difficult in this one!

Using **Karnaugh Map** for each of those I ended up with this **Circuit**:

![](https://steemitimages.com/640x0/https://s26.postimg.org/clnh666i1/image.png)

Decoders:
---------

    Decoders are the **opposite** of an **Encoder** and they actually can also be called **Demultiplexers** or **DEMUX**, cause they also work as the **opposite** of an **Multiplexer**! The only **difference** between DEMUX's and Decoders is actually that the first uses only **1 Input** and gives us **2^n Outputs**, and the second uses **n Inputs** and gives us **2^n Outputs**! I will talk about Decoders to keep things simple, cause DEMUX are more complicated! 

![](https://steemitimages.com/0x0/https://cdn.instructables.com/F8R/QUI5/HQ0HSVLJ/F8RQUI5HQ0HSVLJ.MEDIUM.gif)

    As I already said the Decoder is the opposite of an Encoder, so using the Outputs of an Encoder as Inputs in it's corresponding Decoder we get the Inputs that gave us this Outputs in the Encoder! So, we get the Inputs back! But, this is not the way we use them, cause it can be made much simpler!

    An Decoder **can't have more then 1 Outputs lines have a value of 1**! Cause each Output line represents an Combination (binary number) of Inputs. So, **each Output line represents an minterm or maxterm** of our function! A Decoder mostly has an **inverted Output** so we will have to **use maxterms** or **use minterms and invert the Outputs using an NAND Gate**!

Using that logic we can **implement any Circuit**, **knowing only** where it has **minterms** or **maxterms**!

**Example:**

    Last time we talked about Full-Adders. Let's implement one using an Decoder! We have to use an 3-to-8 Decoder, cause we have 3 Inputs. 

The Truth Table looks like this (if you remember):

![](https://steemitimages.com/640x0/https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQEYzRGEf1mXdt3v_IWEEXDybmv2c2mi7rvi-zdH3apvvKDVvPHuw)

    To use an Decoder for that Circuit we simply have to put a Multi-Input NAND Gate (if Outputs are inverted, else OR) for each of the Outputs and the Inputs will be the corresponding Outputs the Decoder gives us for each Input Combination (Minterms)!

So, we end up with this **Circuit**:

![](https://steemitimages.com/640x0/https://s26.postimg.org/vxdmai92h/image.png)



---
# PRogrammable Logic

***

***

Programmable Logic Devices **PLDs** are the integrated circuits. They contain an array of AND gates & another array of OR gates. There are three kinds of PLDs based on the type of arrays, which has programmable feature.

*   Programmable Read Only Memory
*   Programmable Array Logic
*   Programmable Logic Array

The process of entering the information into these devices is known as **programming**. Basically, users can program these devices or ICs electrically in order to implement the Boolean functions based on the requirement. Here, the term programming refers to hardware programming but not software programming.

Programmable Read Only Memory PROM
----------------------------------

Read Only Memory ROM is a memory device, which stores the binary information permanently. That means, we can’t change that stored information by any means later. If the ROM has programmable feature, then it is called as **Programmable ROM PROM**. The user has the flexibility to program the binary information electrically once by using PROM programmer.

PROM is a programmable logic device that has fixed AND array & Programmable OR array. The **block diagram** of PROM is shown in the following figure.

![PROM](https://www.tutorialspoint.com/digital_circuits/images/prom.jpg)

Here, the inputs of AND gates are not of programmable type. So, we have to generate 2<sup>n</sup> product terms by using 2<sup>n</sup> AND gates having n inputs each. We can implement these product terms by using nx2<sup>n</sup> decoder. So, this decoder generates ‘n’ **min terms**.

Here, the inputs of OR gates are programmable. That means, we can program any number of required product terms, since all the outputs of AND gates are applied as inputs to each OR gate. Therefore, the outputs of PROM will be in the form of **sum of min terms**.

### Example

Let us implement the following **Boolean functions** using PROM.

A(X,Y,Z)\=∑m(5,6,7)

B(X,Y,Z)\=∑m(3,5,6,7)

The given two functions are in sum of min terms form and each function is having three variables X, Y & Z. So, we require a 3 to 8 decoder and two programmable OR gates for producing these two functions. The corresponding **PROM** is shown in the following figure.

![Prom Example](https://www.tutorialspoint.com/digital_circuits/images/prom_example.jpg)

Here, 3 to 8 decoder generates eight min terms. The two programmable OR gates have the access of all these min terms. But, only the required min terms are programmed in order to produce the respective Boolean functions by each OR gate. The symbol ‘X’ is used for programmable connections.

Programmable Array Logic PAL
----------------------------

PAL is a programmable logic device that has Programmable AND array & fixed OR array. The advantage of PAL is that we can generate only the required product terms of Boolean function instead of generating all the min terms by using programmable AND gates. The **block diagram** of PAL is shown in the following figure.

![PAL](https://www.tutorialspoint.com/digital_circuits/images/pal.jpg)

Here, the inputs of AND gates are programmable. That means each AND gate has both normal and complemented inputs of variables. So, based on the requirement, we can program any of those inputs. So, we can generate only the required **product terms** by using these AND gates.

Here, the inputs of OR gates are not of programmable type. So, the number of inputs to each OR gate will be of fixed type. Hence, apply those required product terms to each OR gate as inputs. Therefore, the outputs of PAL will be in the form of **sum of products form**.

### Example

Let us implement the following **Boolean functions** using PAL.

A\=XY+XZ′

A\=XY′+YZ′

The given two functions are in sum of products form. There are two product terms present in each Boolean function. So, we require four programmable AND gates & two fixed OR gates for producing those two functions. The corresponding **PAL** is shown in the following figure.

![Pal Example](https://www.tutorialspoint.com/digital_circuits/images/pal_example.jpg)

The **programmable AND gates** have the access of both normal and complemented inputs of variables. In the above figure, the inputs X, X′, Y, Y′, Z & Z′, are available at the inputs of each AND gate. So, program only the required literals in order to generate one product term by each AND gate. The symbol ‘X’ is used for programmable connections.

Here, the inputs of OR gates are of fixed type. So, the necessary product terms are connected to inputs of each **OR gate**. So that the OR gates produce the respective Boolean functions. The symbol ‘.’ is used for fixed connections.

Programmable Logic Array PLA
----------------------------

PLA is a programmable logic device that has both Programmable AND array & Programmable OR array. Hence, it is the most flexible PLD. The **block diagram** of PLA is shown in the following figure.

![PLA](https://www.tutorialspoint.com/digital_circuits/images/pla.jpg)

Here, the inputs of AND gates are programmable. That means each AND gate has both normal and complemented inputs of variables. So, based on the requirement, we can program any of those inputs. So, we can generate only the required **product terms** by using these AND gates.

Here, the inputs of OR gates are also programmable. So, we can program any number of required product terms, since all the outputs of AND gates are applied as inputs to each OR gate. Therefore, the outputs of PAL will be in the form of **sum of products form**.

### Example

Let us implement the following **Boolean functions** using PLA.

A\=XY+XZ′

B\=XY′+YZ+XZ′

The given two functions are in sum of products form. The number of product terms present in the given Boolean functions A & B are two and three respectively. One product term, Z′X is common in each function.

So, we require four programmable AND gates & two programmable OR gates for producing those two functions. The corresponding **PLA** is shown in the following figure.

![PLA Circuit Diagram](https://www.tutorialspoint.com/digital_circuits/images/pla_circuit_diagram.jpg)

The **programmable AND gates** have the access of both normal and complemented inputs of variables. In the above figure, the inputs X, X′, Y, Y′, Z & Z′, are available at the inputs of each AND gate. So, program only the required literals in order to generate one product term by each AND gate.

All these product terms are available at the inputs of each **programmable OR gate**. But, only program the required product terms in order to produce the respective Boolean functions by each OR gate. The symbol ‘X’ is used for programmable connections.



# Recommendations

- [](https://www.electronics-tutorials.ws/sequential/seq_1.html)

- [The JK Flip Flop](https://www.electronics-tutorials.ws/sequential/seq_2.html)
- [The Shift Register](https://www.electronics-tutorials.ws/sequential/seq_5.html)

- [Johnson Ring Counter](https://www.electronics-tutorials.ws/sequential/seq_6.html)